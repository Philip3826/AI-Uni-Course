# Домашна 1
## Задача за осемте царици

## Описание на използвания алгоритъм:

- **Създаване на началната популация**
За да може нашие генетичен алгоритъм да работи ни трябва начална популация от която да започнат да се генерират нови решения. За целта трябва да определим първо под какъв 
вид ще представим решенията. Избираме да ги представяме като вектор от 8 числа всяко от което представлява царица и нейното място в колоната. Така получаваме че индекса на 
елемент на вектора е координатата отговаряща на колоните, а стойността на елемента - на редовете. Генерирането на началната популация извършваме като създадем предварително
избран от нас брой вектори, съдържащи случайни числа между 1 и 8.

- **Фитнес функция**
Нуждаем се от фитнес функция която да оценява качеството на решенията. Най-директния начин е да броим броя царици които се застрашават в едно решение. Така колкото по-ниска е 
стойността на фитнес фунцкията, толкова по-близко сме до решение. При стойност 0 на функцията имаме валидно решение. Две царици се застрашават една друга , когато са на един ред
или на един диагонал. Не разглеждаме дали са на една колона заради начина по който сме избрали представянето на решението.

- **Кръстосване**
Кръстосването се случва като вземем две решения които ще наричаме родители и ги разделим всеки на по две части, в избрано от нас място(например в средата). След това вземаме лявата
част на единия родител и я слепваме с дясната част на другия родител. Тази стъпка я повтаряме и за останалите две части. По този начин генерираме две нови решения.

-**Генериране на ново поколение**
За да генерираме ново поколоение от решения, първото нещо което трябва да направим е да изберем най-добрите решения от миналото покололение. За целта го сортираме спрямо стойността
на фитнес функцията и вземаме някакъв избран от нас брой от най-добрите решения. След това случайно избираме по две решения от новото ни ограничено множество решения и им прилагаме
кръстосване. Получените две нови решения добавяме към новото поколение. Този процес изпълняваме предварително избран от нас брой пъти и накрая ще получим ново поколение от решения.

-**Мутация**
При генериране на деца можем да зададем вероятност да се промени случайно решението по някакъв начин. Например в алгоритъма задаваме вероятност някое от числата във вектора случайно
да смени стойността си. По този начин се опитваме да подсигурим, че решенията ни няма да зациклят и ще достигнат всички възможни случаи.

- ##Действие на алгоритъма##
Алгоритъма ни започва като създаде начална популация. След това циклично генерира нови поколения като използва предходното поколение, целейки да достигне решение което има 0 за стойност
на фитнес функцията. Ако такова се достигне алгоритъма прекратява изпълнението си. Ако такова не се достигне е зададен лимит на брой поколения които той да генерира преди да се откаже 
и да прекрати действие.

## Използване на алгоритъма
За да се използва алгоритъма е нужен само компилагор на C++. Ако имате такъв компилирайте .cpp файла и го изпълнете. Няма нужда от въвеждане на данни в конзолата, но ако искате да промените
началните условия като начална популация , начин на кръстосване, мутация и т.н. може да се променят стойностите в самия файл.

## Пример
Примерен резултат може да се намери в текстовия файл предоставен в архива. Това е изпълнение на алгоритъма при начална популация 50 решения и избиране на 10те най-добри решения от всяко 
поколение и кръстосването им определен брой пъти. Всяко поколение е означено над него с неговия пореден номер като стартовото поколение е с номер 0. Във файла ще има 3 примера с различен 
брой на кръстосвания и също времето за което се изпълнява алгоритъма.



